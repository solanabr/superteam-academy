import type { Course } from "@/types/course";

export const SAMPLE_COURSES: Course[] = [
  {
    id: "solana-fundamentals",
    slug: "solana-fundamentals",
    title: "Solana Fundamentals",
    description: "Master the core concepts of Solana blockchain development. Learn about accounts, transactions, programs, and the Solana runtime.",
    thumbnail: "/courses/solana-fundamentals.png",
    creator: "Superteam Academy",
    difficulty: "beginner",
    lessonCount: 10,
    challengeCount: 4,
    xpTotal: 500,
    trackId: 0,
    trackLevel: 1,
    duration: "6 hours",
    isActive: true,
    totalCompletions: 1250,
    totalEnrollments: 3800,
    createdAt: "2025-01-15T00:00:00Z",
    modules: [
      {
        id: "m1",
        title: "Introduction to Solana",
        description: "Understanding the Solana ecosystem",
        order: 0,
        lessons: [
          { id: "l1", title: "What is Solana?", description: "An overview of Solana blockchain", order: 0, type: "content", xpReward: 25, duration: "15 min", content: "# What is Solana?\n\nSolana is a high-performance blockchain platform designed for decentralized applications and marketplaces.\n\n## Key Features\n\n- **High throughput**: Up to 65,000 TPS\n- **Low fees**: Fractions of a cent per transaction\n- **Fast finality**: ~400ms block times\n- **Proof of History**: Novel consensus mechanism\n\n## Why Solana?\n\nSolana was created to solve the blockchain trilemma — achieving scalability, security, and decentralization simultaneously. Unlike other chains that sacrifice one for the others, Solana uses innovative techniques like Proof of History (PoH) and Tower BFT to achieve all three." },
          { id: "l2", title: "The Solana Account Model", description: "Understanding accounts, rent, and data storage", order: 1, type: "content", xpReward: 30, duration: "20 min", content: "# The Solana Account Model\n\nEverything on Solana is an account. Understanding the account model is fundamental to building on Solana.\n\n## Account Types\n\n1. **System Accounts** — Hold SOL, owned by the System Program\n2. **Program Accounts** — Contain executable code\n3. **Data Accounts** — Store state for programs\n4. **Token Accounts** — Hold SPL tokens\n\n## Key Concepts\n\n- Every account has an **owner** program\n- Only the owner can modify the account's data\n- Accounts must maintain a minimum **rent-exempt** balance\n- Accounts have a maximum size of 10MB" },
          { id: "l3", title: "Transactions & Instructions", description: "How transactions work on Solana", order: 2, type: "content", xpReward: 30, duration: "20 min", content: "# Transactions & Instructions\n\nTransactions are the fundamental unit of activity on Solana.\n\n## Transaction Structure\n\n- **Signatures**: One or more signatures from required signers\n- **Message**: Contains instructions to execute\n- **Recent Blockhash**: Prevents replay attacks\n\n## Instructions\n\nEach instruction specifies:\n- **Program ID**: Which program to invoke\n- **Accounts**: List of accounts to read/write\n- **Data**: Serialized instruction arguments" },
        ],
      },
      {
        id: "m2",
        title: "Building on Solana",
        description: "Hands-on development basics",
        order: 1,
        lessons: [
          { id: "l4", title: "Setting Up Your Environment", description: "Install Solana CLI and tools", order: 3, type: "content", xpReward: 25, duration: "15 min", content: "# Setting Up Your Development Environment\n\n## Prerequisites\n\n- Node.js 18+\n- Rust (latest stable)\n\n## Install Solana CLI\n\n```bash\nsh -c \"$(curl -sSfL https://release.anza.xyz/stable/install)\"\nsolana --version\n```\n\n## Configure for Devnet\n\n```bash\nsolana config set --url devnet\nsolana-keygen new\nsolana airdrop 2\n```" },
          { id: "l5", title: "Your First Transaction", description: "Send SOL on devnet", order: 4, type: "challenge", xpReward: 50, duration: "30 min", challenge: { language: "typescript", prompt: "Write a function that creates and sends a SOL transfer transaction on devnet.", starterCode: "import { Connection, PublicKey, Transaction, SystemProgram, sendAndConfirmTransaction, Keypair, LAMPORTS_PER_SOL } from '@solana/web3.js';\n\nasync function transferSOL(\n  connection: Connection,\n  from: Keypair,\n  to: PublicKey,\n  amount: number\n): Promise<string> {\n  // Your code here\n  // Create a transfer instruction\n  // Build and send the transaction\n  // Return the transaction signature\n}", solution: "import { Connection, PublicKey, Transaction, SystemProgram, sendAndConfirmTransaction, Keypair, LAMPORTS_PER_SOL } from '@solana/web3.js';\n\nasync function transferSOL(\n  connection: Connection,\n  from: Keypair,\n  to: PublicKey,\n  amount: number\n): Promise<string> {\n  const transaction = new Transaction().add(\n    SystemProgram.transfer({\n      fromPubkey: from.publicKey,\n      toPubkey: to,\n      lamports: amount * LAMPORTS_PER_SOL,\n    })\n  );\n  const signature = await sendAndConfirmTransaction(connection, transaction, [from]);\n  return signature;\n}", testCases: [{ id: "t1", name: "Returns signature string", input: "0.1 SOL transfer", expectedOutput: "string" }], hints: ["Use SystemProgram.transfer to create the instruction", "Use sendAndConfirmTransaction to send it"] } },
          { id: "l6", title: "Working with Keypairs", description: "Generate and manage keypairs", order: 5, type: "challenge", xpReward: 50, duration: "25 min", challenge: { language: "typescript", prompt: "Write functions to generate a new keypair and derive a public key from a base58 string.", starterCode: "import { Keypair, PublicKey } from '@solana/web3.js';\n\nfunction generateKeypair(): { publicKey: string; secretKey: Uint8Array } {\n  // Generate a new keypair\n  // Return public key as base58 and secret key\n}\n\nfunction publicKeyFromString(address: string): PublicKey {\n  // Convert a base58 string to PublicKey\n}", solution: "import { Keypair, PublicKey } from '@solana/web3.js';\n\nfunction generateKeypair(): { publicKey: string; secretKey: Uint8Array } {\n  const keypair = Keypair.generate();\n  return {\n    publicKey: keypair.publicKey.toBase58(),\n    secretKey: keypair.secretKey,\n  };\n}\n\nfunction publicKeyFromString(address: string): PublicKey {\n  return new PublicKey(address);\n}", testCases: [{ id: "t1", name: "Generates valid keypair", input: "", expectedOutput: "valid keypair" }], hints: ["Use Keypair.generate()", "Use new PublicKey(string)"] } },
        ],
      },
      {
        id: "m3",
        title: "Programs & PDAs",
        description: "Program Derived Addresses and on-chain programs",
        order: 2,
        lessons: [
          { id: "l7", title: "Understanding Programs", description: "How Solana programs work", order: 6, type: "content", xpReward: 30, duration: "20 min", content: "# Understanding Solana Programs\n\nPrograms are the smart contracts of Solana. They are stateless — all state is stored in accounts.\n\n## Key Principles\n\n1. Programs are **stateless** — they read/write to accounts\n2. Programs are **deployed** as upgradeable by default\n3. Programs process **instructions** from transactions\n4. Programs can invoke other programs via **CPI** (Cross-Program Invocation)" },
          { id: "l8", title: "Program Derived Addresses", description: "PDAs and their importance", order: 7, type: "content", xpReward: 35, duration: "25 min", content: "# Program Derived Addresses (PDAs)\n\nPDAs are deterministic addresses derived from seeds and a program ID. They are essential for on-chain state management.\n\n## How PDAs Work\n\n```rust\nlet (pda, bump) = Pubkey::find_program_address(\n    &[b\"seed\", user.key().as_ref()],\n    program_id,\n);\n```\n\n## Key Properties\n\n- **Deterministic**: Same seeds always produce the same address\n- **Off-curve**: PDAs are NOT on the Ed25519 curve (no private key)\n- **Program-signable**: Only the owning program can sign for PDAs" },
          { id: "l9", title: "PDA Challenge", description: "Derive and use PDAs", order: 8, type: "challenge", xpReward: 75, duration: "35 min", challenge: { language: "typescript", prompt: "Write a function that derives a PDA for a user profile account.", starterCode: "import { PublicKey } from '@solana/web3.js';\n\nconst PROGRAM_ID = new PublicKey('11111111111111111111111111111111');\n\nfunction deriveProfilePDA(userWallet: PublicKey): [PublicKey, number] {\n  // Derive PDA with seeds: [\"profile\", userWallet]\n  // Return [pda, bump]\n}", solution: "import { PublicKey } from '@solana/web3.js';\n\nconst PROGRAM_ID = new PublicKey('11111111111111111111111111111111');\n\nfunction deriveProfilePDA(userWallet: PublicKey): [PublicKey, number] {\n  return PublicKey.findProgramAddressSync(\n    [Buffer.from('profile'), userWallet.toBuffer()],\n    PROGRAM_ID,\n  );\n}", testCases: [{ id: "t1", name: "Returns PDA tuple", input: "valid pubkey", expectedOutput: "[PublicKey, number]" }], hints: ["Use PublicKey.findProgramAddressSync", "Seeds should be Buffer arrays"] } },
          { id: "l10", title: "Final Quiz", description: "Test your Solana knowledge", order: 9, type: "challenge", xpReward: 100, duration: "20 min", challenge: { language: "typescript", prompt: "Complete the quiz by implementing the missing functions.", starterCode: "// Q1: What is the maximum account size on Solana?\nfunction maxAccountSize(): number {\n  // Return the answer in bytes\n}\n\n// Q2: How many signatures can a transaction have?\nfunction maxSignatures(): number {\n  // Return the maximum\n}", solution: "function maxAccountSize(): number {\n  return 10_485_760; // 10MB\n}\n\nfunction maxSignatures(): number {\n  return 12; // Limited by packet size\n}", testCases: [{ id: "t1", name: "Correct answers", input: "", expectedOutput: "10485760, 12" }], hints: ["10MB in bytes", "Limited by transaction packet size"] } },
        ],
      },
    ],
  },
  {
    id: "anchor-beginner",
    slug: "anchor-beginner",
    title: "Anchor Framework: Getting Started",
    description: "Build your first Solana program using the Anchor framework. Learn about macros, account validation, and testing.",
    thumbnail: "/courses/anchor-beginner.png",
    creator: "Superteam Academy",
    difficulty: "beginner",
    lessonCount: 8,
    challengeCount: 3,
    xpTotal: 500,
    trackId: 1,
    trackLevel: 1,
    duration: "5 hours",
    isActive: true,
    totalCompletions: 890,
    totalEnrollments: 2400,
    createdAt: "2025-02-01T00:00:00Z",
    modules: [
      {
        id: "am1", title: "Anchor Basics", description: "Getting started with Anchor", order: 0,
        lessons: [
          { id: "al1", title: "What is Anchor?", description: "Introduction to the Anchor framework", order: 0, type: "content", xpReward: 30, duration: "15 min", content: "# What is Anchor?\n\nAnchor is a framework for Solana programs. It provides:\n\n- **Macros** for account validation\n- **IDL generation** for client integration\n- **Testing framework** with TypeScript\n- **CLI** for build and deploy" },
          { id: "al2", title: "Project Structure", description: "Anchor project layout", order: 1, type: "content", xpReward: 30, duration: "15 min", content: "# Anchor Project Structure\n\n```\nmy-project/\n├── programs/\n│   └── my-program/\n│       └── src/\n│           └── lib.rs\n├── tests/\n├── Anchor.toml\n└── Cargo.toml\n```" },
          { id: "al3", title: "Your First Anchor Program", description: "Build a counter program", order: 2, type: "challenge", xpReward: 75, duration: "40 min", challenge: { language: "rust", prompt: "Create a simple counter program with initialize and increment instructions.", starterCode: "use anchor_lang::prelude::*;\n\ndeclare_id!(\"11111111111111111111111111111111\");\n\n#[program]\npub mod counter {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        // Initialize the counter to 0\n        Ok(())\n    }\n\n    pub fn increment(ctx: Context<Increment>) -> Result<()> {\n        // Increment the counter by 1\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize {}\n\n#[derive(Accounts)]\npub struct Increment {}\n\n#[account]\npub struct Counter {\n    pub count: u64,\n}", solution: "use anchor_lang::prelude::*;\n\ndeclare_id!(\"11111111111111111111111111111111\");\n\n#[program]\npub mod counter {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        let counter = &mut ctx.accounts.counter;\n        counter.count = 0;\n        Ok(())\n    }\n\n    pub fn increment(ctx: Context<Increment>) -> Result<()> {\n        let counter = &mut ctx.accounts.counter;\n        counter.count += 1;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = user, space = 8 + 8)]\n    pub counter: Account<'info, Counter>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Increment<'info> {\n    #[account(mut)]\n    pub counter: Account<'info, Counter>,\n}\n\n#[account]\npub struct Counter {\n    pub count: u64,\n}", testCases: [{ id: "t1", name: "Counter initializes to 0", input: "init", expectedOutput: "count: 0" }], hints: ["Add lifetime 'info to your account structs", "Use #[account(init, payer = user, space = 8 + 8)]"] } },
        ],
      },
      {
        id: "am2", title: "Account Validation", description: "Anchor constraints and validation", order: 1,
        lessons: [
          { id: "al4", title: "Account Constraints", description: "Using Anchor constraints", order: 3, type: "content", xpReward: 35, duration: "25 min", content: "# Anchor Account Constraints\n\n## Common Constraints\n\n- `#[account(init)]` — Initialize a new account\n- `#[account(mut)]` — Account is mutable\n- `#[account(seeds = [...], bump)]` — PDA validation\n- `#[account(has_one = authority)]` — Check field matches\n- `#[account(close = recipient)]` — Close account" },
          { id: "al5", title: "PDAs in Anchor", description: "Program Derived Addresses with Anchor", order: 4, type: "content", xpReward: 35, duration: "25 min", content: "# PDAs in Anchor\n\nAnchor makes working with PDAs straightforward:\n\n```rust\n#[account(\n    init,\n    seeds = [b\"user-profile\", user.key().as_ref()],\n    bump,\n    payer = user,\n    space = 8 + UserProfile::INIT_SPACE,\n)]\npub profile: Account<'info, UserProfile>,\n```" },
          { id: "al6", title: "Build a Vault", description: "Create a SOL vault with PDA", order: 5, type: "challenge", xpReward: 80, duration: "45 min", challenge: { language: "rust", prompt: "Build a vault program that lets users deposit and withdraw SOL.", starterCode: "use anchor_lang::prelude::*;\n\ndeclare_id!(\"11111111111111111111111111111111\");\n\n#[program]\npub mod vault {\n    use super::*;\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        // Transfer SOL from user to vault PDA\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Deposit {}", solution: "use anchor_lang::prelude::*;\nuse anchor_lang::system_program;\n\ndeclare_id!(\"11111111111111111111111111111111\");\n\n#[program]\npub mod vault {\n    use super::*;\n\n    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {\n        system_program::transfer(\n            CpiContext::new(\n                ctx.accounts.system_program.to_account_info(),\n                system_program::Transfer {\n                    from: ctx.accounts.user.to_account_info(),\n                    to: ctx.accounts.vault.to_account_info(),\n                },\n            ),\n            amount,\n        )?;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(mut)]\n    pub user: Signer<'info>,\n    #[account(mut, seeds = [b\"vault\"], bump)]\n    pub vault: SystemAccount<'info>,\n    pub system_program: Program<'info, System>,\n}", testCases: [{ id: "t1", name: "Deposits SOL", input: "1 SOL", expectedOutput: "success" }], hints: ["Use system_program::transfer for CPI", "Vault PDA with seeds [b\"vault\"]"] } },
        ],
      },
      {
        id: "am3", title: "Testing & Deployment", description: "Testing and deploying Anchor programs", order: 2,
        lessons: [
          { id: "al7", title: "Testing with Anchor", description: "Write tests for your programs", order: 6, type: "content", xpReward: 30, duration: "20 min", content: "# Testing with Anchor\n\n## TypeScript Tests\n\n```typescript\nimport * as anchor from '@coral-xyz/anchor';\n\ndescribe('my-program', () => {\n  const provider = anchor.AnchorProvider.env();\n  anchor.setProvider(provider);\n\n  it('initializes', async () => {\n    const tx = await program.methods\n      .initialize()\n      .rpc();\n    console.log('TX:', tx);\n  });\n});\n```" },
          { id: "al8", title: "Deploy to Devnet", description: "Deploying your first program", order: 7, type: "challenge", xpReward: 85, duration: "30 min", challenge: { language: "typescript", prompt: "Write a test that initializes a counter and increments it twice.", starterCode: "import * as anchor from '@coral-xyz/anchor';\nimport { Program } from '@coral-xyz/anchor';\nimport { expect } from 'chai';\n\ndescribe('counter', () => {\n  const provider = anchor.AnchorProvider.env();\n  anchor.setProvider(provider);\n\n  it('initialize and increment twice', async () => {\n    // Write your test here\n  });\n});", solution: "import * as anchor from '@coral-xyz/anchor';\nimport { Program } from '@coral-xyz/anchor';\nimport { expect } from 'chai';\n\ndescribe('counter', () => {\n  const provider = anchor.AnchorProvider.env();\n  anchor.setProvider(provider);\n\n  it('initialize and increment twice', async () => {\n    const counter = anchor.web3.Keypair.generate();\n    // Initialize\n    await program.methods.initialize()\n      .accounts({ counter: counter.publicKey })\n      .signers([counter])\n      .rpc();\n    let account = await program.account.counter.fetch(counter.publicKey);\n    expect(account.count.toNumber()).to.equal(0);\n    // Increment twice\n    await program.methods.increment()\n      .accounts({ counter: counter.publicKey })\n      .rpc();\n    await program.methods.increment()\n      .accounts({ counter: counter.publicKey })\n      .rpc();\n    account = await program.account.counter.fetch(counter.publicKey);\n    expect(account.count.toNumber()).to.equal(2);\n  });\n});", testCases: [{ id: "t1", name: "Counter reaches 2", input: "init + 2 increments", expectedOutput: "count: 2" }], hints: ["Generate a new keypair for the counter", "Fetch the account to check state"] } },
        ],
      },
    ],
  },
  {
    id: "rust-for-solana",
    slug: "rust-for-solana",
    title: "Rust for Solana Developers",
    description: "Learn Rust fundamentals tailored for Solana program development. Covers ownership, borrowing, structs, enums, and error handling.",
    thumbnail: "/courses/rust-for-solana.png",
    creator: "Superteam Academy",
    difficulty: "intermediate",
    lessonCount: 12,
    challengeCount: 5,
    xpTotal: 1000,
    trackId: 2,
    trackLevel: 1,
    duration: "8 hours",
    isActive: true,
    totalCompletions: 620,
    totalEnrollments: 1800,
    createdAt: "2025-03-01T00:00:00Z",
    modules: [
      {
        id: "rm1", title: "Rust Basics", description: "Core Rust concepts", order: 0,
        lessons: [
          { id: "rl1", title: "Variables & Types", description: "Rust type system basics", order: 0, type: "content", xpReward: 40, duration: "20 min", content: "# Variables & Types in Rust\n\n## Immutability by Default\n\n```rust\nlet x = 5; // immutable\nlet mut y = 10; // mutable\n```\n\n## Common Types\n\n- `u8`, `u16`, `u32`, `u64`, `u128` — unsigned integers\n- `i8`, `i16`, `i32`, `i64`, `i128` — signed integers\n- `bool`, `String`, `&str`, `Vec<T>`\n\n## Why This Matters for Solana\n\nSolana programs deal with specific byte sizes. Knowing `u64` vs `u32` matters for account space calculations." },
          { id: "rl2", title: "Ownership & Borrowing", description: "Rust's memory model", order: 1, type: "content", xpReward: 50, duration: "30 min", content: "# Ownership & Borrowing\n\n## The Three Rules\n\n1. Each value has exactly one owner\n2. When the owner goes out of scope, the value is dropped\n3. You can have either one mutable reference OR any number of immutable references" },
          { id: "rl3", title: "Structs & Enums", description: "Custom data types", order: 2, type: "challenge", xpReward: 60, duration: "25 min", challenge: { language: "rust", prompt: "Define a Token struct and a TokenType enum.", starterCode: "// Define a TokenType enum with variants: Fungible, NonFungible, SemiFungible\n\n// Define a Token struct with fields: name (String), symbol (String), supply (u64), token_type (TokenType)\n", solution: "#[derive(Debug)]\nenum TokenType {\n    Fungible,\n    NonFungible,\n    SemiFungible,\n}\n\n#[derive(Debug)]\nstruct Token {\n    name: String,\n    symbol: String,\n    supply: u64,\n    token_type: TokenType,\n}", testCases: [{ id: "t1", name: "Valid struct", input: "", expectedOutput: "compiles" }], hints: ["Use #[derive(Debug)] for printing", "enum variants use PascalCase"] } },
        ],
      },
      {
        id: "rm2", title: "Advanced Rust for Solana", description: "Patterns used in Solana programs", order: 1,
        lessons: [
          { id: "rl4", title: "Error Handling", description: "Result, Option, and custom errors", order: 3, type: "content", xpReward: 45, duration: "25 min", content: "# Error Handling in Rust\n\n## Result<T, E>\n\n```rust\nfn divide(a: u64, b: u64) -> Result<u64, &'static str> {\n    if b == 0 {\n        return Err(\"division by zero\");\n    }\n    Ok(a / b)\n}\n```\n\n## The ? Operator\n\nPropagates errors automatically:\n```rust\nlet result = divide(10, 2)?;\n```" },
          { id: "rl5", title: "Traits & Generics", description: "Polymorphism in Rust", order: 4, type: "content", xpReward: 45, duration: "25 min", content: "# Traits & Generics\n\n## Defining Traits\n\n```rust\ntrait Validate {\n    fn is_valid(&self) -> bool;\n}\n```\n\n## Implementing Traits\n\n```rust\nimpl Validate for Course {\n    fn is_valid(&self) -> bool {\n        self.lesson_count > 0 && self.is_active\n    }\n}\n```" },
          { id: "rl6", title: "Serialization", description: "Borsh serialization for Solana", order: 5, type: "challenge", xpReward: 70, duration: "30 min", challenge: { language: "rust", prompt: "Implement a serializable account struct.", starterCode: "use borsh::{BorshSerialize, BorshDeserialize};\n\n// Create a UserProfile struct with:\n// - authority: [u8; 32]\n// - xp: u64\n// - level: u8\n// - streak: u16\n// Derive BorshSerialize and BorshDeserialize\n", solution: "use borsh::{BorshSerialize, BorshDeserialize};\n\n#[derive(BorshSerialize, BorshDeserialize, Debug)]\npub struct UserProfile {\n    pub authority: [u8; 32],\n    pub xp: u64,\n    pub level: u8,\n    pub streak: u16,\n}", testCases: [{ id: "t1", name: "Serializable", input: "", expectedOutput: "compiles with borsh" }], hints: ["Derive both BorshSerialize and BorshDeserialize"] } },
        ],
      },
    ],
  },
  {
    id: "defi-basics",
    slug: "defi-basics",
    title: "DeFi on Solana",
    description: "Understand the fundamentals of decentralized finance on Solana. Learn about AMMs, lending protocols, and token economics.",
    thumbnail: "/courses/defi-basics.png",
    creator: "Superteam Academy",
    difficulty: "intermediate",
    lessonCount: 8,
    challengeCount: 2,
    xpTotal: 1000,
    trackId: 3,
    trackLevel: 1,
    duration: "6 hours",
    isActive: true,
    totalCompletions: 340,
    totalEnrollments: 1200,
    createdAt: "2025-04-01T00:00:00Z",
    modules: [
      {
        id: "dm1", title: "DeFi Foundations", description: "Core DeFi concepts on Solana", order: 0,
        lessons: [
          { id: "dl1", title: "What is DeFi?", description: "Decentralized Finance overview", order: 0, type: "content", xpReward: 40, duration: "20 min", content: "# DeFi on Solana\n\nDecentralized Finance enables permissionless financial services on-chain.\n\n## Key Protocols\n\n- **Jupiter** — DEX aggregator\n- **Raydium** — AMM & liquidity\n- **Marinade** — Liquid staking\n- **Drift** — Perpetuals" },
          { id: "dl2", title: "Token Standards", description: "SPL Token & Token-2022", order: 1, type: "content", xpReward: 50, duration: "30 min", content: "# Token Standards on Solana\n\n## SPL Token\nThe original token program.\n\n## Token-2022\nExtended token program with:\n- Transfer fees\n- Non-transferable tokens\n- Permanent delegate\n- Metadata pointer\n- Confidential transfers" },
        ],
      },
    ],
  },
  {
    id: "program-security",
    slug: "program-security",
    title: "Solana Program Security",
    description: "Learn to identify and prevent common vulnerabilities in Solana programs. Covers account validation, arithmetic safety, and re-entrancy.",
    thumbnail: "/courses/program-security.png",
    creator: "Superteam Academy",
    difficulty: "advanced",
    lessonCount: 10,
    challengeCount: 4,
    xpTotal: 2000,
    trackId: 4,
    trackLevel: 1,
    duration: "10 hours",
    prerequisiteId: "anchor-beginner",
    isActive: true,
    totalCompletions: 180,
    totalEnrollments: 600,
    createdAt: "2025-05-01T00:00:00Z",
    modules: [
      {
        id: "sm1", title: "Common Vulnerabilities", description: "Top security issues", order: 0,
        lessons: [
          { id: "sl1", title: "Missing Account Validation", description: "The #1 vulnerability", order: 0, type: "content", xpReward: 60, duration: "30 min", content: "# Missing Account Validation\n\nThe most common vulnerability in Solana programs.\n\n## The Problem\n\n```rust\n// BAD: No validation\npub fn withdraw(ctx: Context<Withdraw>) -> Result<()> {\n    // Anyone could pass any account!\n}\n```\n\n## The Fix\n\n```rust\n#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(mut, has_one = authority)]\n    pub vault: Account<'info, Vault>,\n    pub authority: Signer<'info>,\n}\n```" },
          { id: "sl2", title: "Arithmetic Overflow", description: "Safe math practices", order: 1, type: "content", xpReward: 60, duration: "25 min", content: "# Arithmetic Safety\n\n## Never Use Raw Arithmetic\n\n```rust\n// BAD: Can overflow\nlet total = amount_a + amount_b;\n\n// GOOD: Checked arithmetic\nlet total = amount_a.checked_add(amount_b)\n    .ok_or(ErrorCode::ArithmeticOverflow)?;\n```" },
        ],
      },
    ],
  },
  {
    id: "anchor-intermediate",
    slug: "anchor-intermediate",
    title: "Anchor Intermediate: Advanced Patterns",
    description: "Deep dive into Anchor patterns including CPIs, PDAs, Token operations, and complex account structures.",
    thumbnail: "/courses/anchor-intermediate.png",
    creator: "Superteam Academy",
    difficulty: "intermediate",
    lessonCount: 10,
    challengeCount: 4,
    xpTotal: 1000,
    trackId: 1,
    trackLevel: 2,
    duration: "8 hours",
    prerequisiteId: "anchor-beginner",
    isActive: true,
    totalCompletions: 280,
    totalEnrollments: 900,
    createdAt: "2025-06-01T00:00:00Z",
    modules: [
      {
        id: "aim1", title: "Advanced Anchor", description: "CPIs and token operations", order: 0,
        lessons: [
          { id: "ail1", title: "Cross-Program Invocations", description: "Calling other programs", order: 0, type: "content", xpReward: 50, duration: "30 min", content: "# Cross-Program Invocations (CPI)\n\nCPIs allow programs to call other programs.\n\n```rust\nlet cpi_ctx = CpiContext::new_with_signer(\n    token_program.to_account_info(),\n    MintTo { mint, to, authority },\n    &[&seeds],\n);\ntoken::mint_to(cpi_ctx, amount)?;\n```" },
          { id: "ail2", title: "Token Operations", description: "SPL Token with Anchor", order: 1, type: "content", xpReward: 50, duration: "30 min", content: "# Token Operations with Anchor\n\n## Creating a Mint\n\n```rust\n#[account(\n    init,\n    payer = authority,\n    mint::decimals = 0,\n    mint::authority = config,\n)]\npub mint: Account<'info, Mint>,\n```" },
        ],
      },
    ],
  },
];
