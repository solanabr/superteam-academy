"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/loglevel";
exports.ids = ["vendor-chunks/loglevel"];
exports.modules = {

/***/ "(ssr)/../../node_modules/loglevel/lib/loglevel.js":
/*!***************************************************!*\
  !*** ../../node_modules/loglevel/lib/loglevel.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/ (function(root, definition) {\n    \"use strict\";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(void 0, function() {\n    \"use strict\";\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = \"undefined\" !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n    var _loggersByName = {};\n    var defaultLogger = null;\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === \"function\") {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [\n                        obj,\n                        arguments\n                    ]);\n                };\n            }\n        }\n    }\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [\n                    console,\n                    arguments\n                ]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === \"debug\") {\n            methodName = \"log\";\n        }\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === \"trace\" && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, \"log\");\n        } else {\n            return noop;\n        }\n    }\n    // These private functions always need `this` to be set properly\n    function replaceLoggingMethods() {\n        /*jshint validthis:true */ var level = this.getLevel();\n        // Replace the actual methods.\n        for(var i = 0; i < logMethods.length; i++){\n            var methodName = logMethods[i];\n            this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);\n        }\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n        // Return any important warnings.\n        if (typeof console === undefinedType && level < this.levels.SILENT) {\n            return \"No console available for logging\";\n        }\n    }\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName) {\n        return function() {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, _level, _loggerName) {\n        /*jshint validthis:true */ return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n    function Logger(name, factory) {\n        // Private instance variables.\n        var self = this;\n        /**\n       * The level inherited from a parent logger (or a global default). We\n       * cache this here rather than delegating to the parent so that it stays\n       * in sync with the actual logging methods that we have installed (the\n       * parent could change levels but we might not have rebuilt the loggers\n       * in this child yet).\n       * @type {number}\n       */ var inheritedLevel;\n        /**\n       * The default level for this logger, if any. If set, this overrides\n       * `inheritedLevel`.\n       * @type {number|null}\n       */ var defaultLevel;\n        /**\n       * A user-specific level for this logger. If set, this overrides\n       * `defaultLevel`.\n       * @type {number|null}\n       */ var userLevel;\n        var storageKey = \"loglevel\";\n        if (typeof name === \"string\") {\n            storageKey += \":\" + name;\n        } else if (typeof name === \"symbol\") {\n            storageKey = undefined;\n        }\n        function persistLevelIfPossible(levelNum) {\n            var levelName = (logMethods[levelNum] || \"silent\").toUpperCase();\n            if (\"undefined\" === undefinedType || !storageKey) return;\n            // Use localStorage if available\n            try {\n                window.localStorage[storageKey] = levelName;\n                return;\n            } catch (ignore) {}\n            // Use session cookie as fallback\n            try {\n                window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n            } catch (ignore) {}\n        }\n        function getPersistedLevel() {\n            var storedLevel;\n            if (\"undefined\" === undefinedType || !storageKey) return;\n            try {\n                storedLevel = window.localStorage[storageKey];\n            } catch (ignore) {}\n            // Fallback to cookies if local storage gives us nothing\n            if (typeof storedLevel === undefinedType) {\n                try {\n                    var cookie = window.document.cookie;\n                    var cookieName = encodeURIComponent(storageKey);\n                    var location = cookie.indexOf(cookieName + \"=\");\n                    if (location !== -1) {\n                        storedLevel = /^([^;]+)/.exec(cookie.slice(location + cookieName.length + 1))[1];\n                    }\n                } catch (ignore) {}\n            }\n            // If the stored level is not valid, treat it as if nothing was stored.\n            if (self.levels[storedLevel] === undefined) {\n                storedLevel = undefined;\n            }\n            return storedLevel;\n        }\n        function clearPersistedLevel() {\n            if (\"undefined\" === undefinedType || !storageKey) return;\n            // Use localStorage if available\n            try {\n                window.localStorage.removeItem(storageKey);\n            } catch (ignore) {}\n            // Use session cookie as fallback\n            try {\n                window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n            } catch (ignore) {}\n        }\n        function normalizeLevel(input) {\n            var level = input;\n            if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n                level = self.levels[level.toUpperCase()];\n            }\n            if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n                return level;\n            } else {\n                throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n            }\n        }\n        /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */ self.name = name;\n        self.levels = {\n            \"TRACE\": 0,\n            \"DEBUG\": 1,\n            \"INFO\": 2,\n            \"WARN\": 3,\n            \"ERROR\": 4,\n            \"SILENT\": 5\n        };\n        self.methodFactory = factory || defaultMethodFactory;\n        self.getLevel = function() {\n            if (userLevel != null) {\n                return userLevel;\n            } else if (defaultLevel != null) {\n                return defaultLevel;\n            } else {\n                return inheritedLevel;\n            }\n        };\n        self.setLevel = function(level, persist) {\n            userLevel = normalizeLevel(level);\n            if (persist !== false) {\n                persistLevelIfPossible(userLevel);\n            }\n            // NOTE: in v2, this should call rebuild(), which updates children.\n            return replaceLoggingMethods.call(self);\n        };\n        self.setDefaultLevel = function(level) {\n            defaultLevel = normalizeLevel(level);\n            if (!getPersistedLevel()) {\n                self.setLevel(level, false);\n            }\n        };\n        self.resetLevel = function() {\n            userLevel = null;\n            clearPersistedLevel();\n            replaceLoggingMethods.call(self);\n        };\n        self.enableAll = function(persist) {\n            self.setLevel(self.levels.TRACE, persist);\n        };\n        self.disableAll = function(persist) {\n            self.setLevel(self.levels.SILENT, persist);\n        };\n        self.rebuild = function() {\n            if (defaultLogger !== self) {\n                inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n            }\n            replaceLoggingMethods.call(self);\n            if (defaultLogger === self) {\n                for(var childName in _loggersByName){\n                    _loggersByName[childName].rebuild();\n                }\n            }\n        };\n        // Initialize all the internal levels.\n        inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : \"WARN\");\n        var initialLevel = getPersistedLevel();\n        if (initialLevel != null) {\n            userLevel = normalizeLevel(initialLevel);\n        }\n        replaceLoggingMethods.call(self);\n    }\n    /*\n     *\n     * Top-level API\n     *\n     */ defaultLogger = new Logger();\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n            throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n        var logger = _loggersByName[name];\n        if (!logger) {\n            logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n    // Grab the current global log variable in case of overwrite\n    var _log = \"undefined\" !== undefinedType ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (\"undefined\" !== undefinedType && window.log === defaultLogger) {\n            window.log = _log;\n        }\n        return defaultLogger;\n    };\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n    // ES6 default export, for compatibility\n    defaultLogger[\"default\"] = defaultLogger;\n    return defaultLogger;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7O0FBS0EsR0FDQyxVQUFVQSxJQUFJLEVBQUVDLFVBQVU7SUFDdkI7SUFDQSxJQUFJLElBQTBDLEVBQUU7UUFDNUNDLG9DQUFPRCxVQUFVQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtHQUFDQTtJQUN0QixPQUFPLEVBSU47QUFDTCxHQUFFLFFBQU07SUFDSjtJQUVBLDBEQUEwRDtJQUMxRCxJQUFJTSxPQUFPLFlBQVk7SUFDdkIsSUFBSUMsZ0JBQWdCO0lBQ3BCLElBQUlDLE9BQU8sZ0JBQW1CRCxpQkFBbUIsT0FBT0UsT0FBT0MsU0FBUyxLQUFLSCxpQkFDekUsa0JBQWtCSSxJQUFJLENBQUNGLE9BQU9DLFNBQVMsQ0FBQ0UsU0FBUztJQUdyRCxJQUFJQyxhQUFhO1FBQ2I7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBRUQsSUFBSUMsaUJBQWlCLENBQUM7SUFDdEIsSUFBSUMsZ0JBQWdCO0lBRXBCLGdFQUFnRTtJQUNoRSxTQUFTQyxXQUFXQyxHQUFHLEVBQUVDLFVBQVU7UUFDL0IsSUFBSUMsU0FBU0YsR0FBRyxDQUFDQyxXQUFXO1FBQzVCLElBQUksT0FBT0MsT0FBT0MsSUFBSSxLQUFLLFlBQVk7WUFDbkMsT0FBT0QsT0FBT0MsSUFBSSxDQUFDSDtRQUN2QixPQUFPO1lBQ0gsSUFBSTtnQkFDQSxPQUFPSSxTQUFTQyxTQUFTLENBQUNGLElBQUksQ0FBQ0csSUFBSSxDQUFDSixRQUFRRjtZQUNoRCxFQUFFLE9BQU9PLEdBQUc7Z0JBQ1IsNkRBQTZEO2dCQUM3RCxPQUFPO29CQUNILE9BQU9ILFNBQVNDLFNBQVMsQ0FBQ0csS0FBSyxDQUFDQSxLQUFLLENBQUNOLFFBQVE7d0JBQUNGO3dCQUFLUztxQkFBVTtnQkFDbEU7WUFDSjtRQUNKO0lBQ0o7SUFFQSwrRUFBK0U7SUFDL0UsU0FBU0M7UUFDTCxJQUFJQyxRQUFRdkIsR0FBRyxF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U3ZFLGNBQWMsQ0FBQ3dCLEtBQUs7UUFDakMsSUFBSSxDQUFDK0MsUUFBUTtZQUNUQSxTQUFTdkUsY0FBYyxDQUFDd0IsS0FBSyxHQUFHLElBQUlRLE9BQ2hDUixNQUNBdkIsY0FBY3NCLGFBQWE7UUFFbkM7UUFDQSxPQUFPZ0Q7SUFDWDtJQUVBLDREQUE0RDtJQUM1RCxJQUFJQyxPQUFPLGdCQUFtQi9FLGdCQUFpQkUsT0FBT0osR0FBRyxHQUFHMEI7SUFDNURoQixjQUFjd0UsVUFBVSxHQUFHO1FBQ3ZCLElBQUksZ0JBQWtCaEYsaUJBQ2ZFLE9BQU9KLEdBQUcsS0FBS1UsZUFBZTtZQUNqQ04sT0FBT0osR0FBRyxHQUFHaUY7UUFDakI7UUFFQSxPQUFPdkU7SUFDWDtJQUVBQSxjQUFjeUUsVUFBVSxHQUFHLFNBQVNBO1FBQ2hDLE9BQU8xRTtJQUNYO0lBRUEsd0NBQXdDO0lBQ3hDQyxhQUFhLENBQUMsVUFBVSxHQUFHQTtJQUUzQixPQUFPQTtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanM/MWRjMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG4gICAgdmFyIGlzSUUgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yICE9PSB1bmRlZmluZWRUeXBlKSAmJiAoXG4gICAgICAgIC9UcmlkZW50XFwvfE1TSUUgLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxuICAgICk7XG5cbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBcIndhcm5cIixcbiAgICAgICAgXCJlcnJvclwiXG4gICAgXTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbnVsbDtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJhY2UoKSBkb2Vzbid0IHByaW50IHRoZSBtZXNzYWdlIGluIElFLCBzbyBmb3IgdGhhdCBjYXNlIHdlIG5lZWQgdG8gd3JhcCBpdFxuICAgIGZ1bmN0aW9uIHRyYWNlRm9ySUUoKSB7XG4gICAgICAgIGlmIChjb25zb2xlLmxvZykge1xuICAgICAgICAgICAgaWYgKGNvbnNvbGUubG9nLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gb2xkIElFLCBuYXRpdmUgY29uc29sZSBtZXRob2RzIHRoZW1zZWx2ZXMgZG9uJ3QgaGF2ZSBhcHBseSgpLlxuICAgICAgICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShjb25zb2xlLmxvZywgW2NvbnNvbGUsIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zb2xlLnRyYWNlKSBjb25zb2xlLnRyYWNlKCk7XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09ICd0cmFjZScgJiYgaXNJRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNlRm9ySUU7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcygpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5nZXRMZXZlbCgpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGFjdHVhbCBtZXRob2RzLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICAgICAgbm9vcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCB0aGlzLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1Z1xuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG5cbiAgICAgICAgLy8gUmV0dXJuIGFueSBpbXBvcnRhbnQgd2FybmluZ3MuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHRoaXMubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBfbGV2ZWwsIF9sb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGZhY3RvcnkpIHtcbiAgICAgIC8vIFByaXZhdGUgaW5zdGFuY2UgdmFyaWFibGVzLlxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbGV2ZWwgaW5oZXJpdGVkIGZyb20gYSBwYXJlbnQgbG9nZ2VyIChvciBhIGdsb2JhbCBkZWZhdWx0KS4gV2VcbiAgICAgICAqIGNhY2hlIHRoaXMgaGVyZSByYXRoZXIgdGhhbiBkZWxlZ2F0aW5nIHRvIHRoZSBwYXJlbnQgc28gdGhhdCBpdCBzdGF5c1xuICAgICAgICogaW4gc3luYyB3aXRoIHRoZSBhY3R1YWwgbG9nZ2luZyBtZXRob2RzIHRoYXQgd2UgaGF2ZSBpbnN0YWxsZWQgKHRoZVxuICAgICAgICogcGFyZW50IGNvdWxkIGNoYW5nZSBsZXZlbHMgYnV0IHdlIG1pZ2h0IG5vdCBoYXZlIHJlYnVpbHQgdGhlIGxvZ2dlcnNcbiAgICAgICAqIGluIHRoaXMgY2hpbGQgeWV0KS5cbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHZhciBpbmhlcml0ZWRMZXZlbDtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGRlZmF1bHQgbGV2ZWwgZm9yIHRoaXMgbG9nZ2VyLCBpZiBhbnkuIElmIHNldCwgdGhpcyBvdmVycmlkZXNcbiAgICAgICAqIGBpbmhlcml0ZWRMZXZlbGAuXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfG51bGx9XG4gICAgICAgKi9cbiAgICAgIHZhciBkZWZhdWx0TGV2ZWw7XG4gICAgICAvKipcbiAgICAgICAqIEEgdXNlci1zcGVjaWZpYyBsZXZlbCBmb3IgdGhpcyBsb2dnZXIuIElmIHNldCwgdGhpcyBvdmVycmlkZXNcbiAgICAgICAqIGBkZWZhdWx0TGV2ZWxgLlxuICAgICAgICogQHR5cGUge251bWJlcnxudWxsfVxuICAgICAgICovXG4gICAgICB2YXIgdXNlckxldmVsO1xuXG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgc3RvcmFnZUtleSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWVOYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoY29va2llTmFtZSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2llLnNsaWNlKGxvY2F0aW9uICsgY29va2llTmFtZS5sZW5ndGggKyAxKVxuICAgICAgICAgICAgICAgICAgICAgIClbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNsZWFyUGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPTsgZXhwaXJlcz1UaHUsIDAxIEphbiAxOTcwIDAwOjAwOjAwIFVUQ1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbm9ybWFsaXplTGV2ZWwoaW5wdXQpIHtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSBpbnB1dDtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICByZXR1cm4gbGV2ZWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgaW5wdXQpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqXG4gICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgc2VsZi5uYW1lID0gbmFtZTtcblxuICAgICAgc2VsZi5sZXZlbHMgPSB7IFwiVFJBQ0VcIjogMCwgXCJERUJVR1wiOiAxLCBcIklORk9cIjogMiwgXCJXQVJOXCI6IDMsXG4gICAgICAgICAgXCJFUlJPUlwiOiA0LCBcIlNJTEVOVFwiOiA1fTtcblxuICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTtcblxuICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodXNlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VyTGV2ZWw7XG4gICAgICAgICAgfSBlbHNlIGlmIChkZWZhdWx0TGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRMZXZlbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluaGVyaXRlZExldmVsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICB1c2VyTGV2ZWwgPSBub3JtYWxpemVMZXZlbChsZXZlbCk7XG4gICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUodXNlckxldmVsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBOT1RFOiBpbiB2MiwgdGhpcyBzaG91bGQgY2FsbCByZWJ1aWxkKCksIHdoaWNoIHVwZGF0ZXMgY2hpbGRyZW4uXG4gICAgICAgICAgcmV0dXJuIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBkZWZhdWx0TGV2ZWwgPSBub3JtYWxpemVMZXZlbChsZXZlbCk7XG4gICAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnJlc2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdXNlckxldmVsID0gbnVsbDtcbiAgICAgICAgICBjbGVhclBlcnNpc3RlZExldmVsKCk7XG4gICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnJlYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRMb2dnZXIgIT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgaW5oZXJpdGVkTGV2ZWwgPSBub3JtYWxpemVMZXZlbChkZWZhdWx0TG9nZ2VyLmdldExldmVsKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmKTtcblxuICAgICAgICAgIGlmIChkZWZhdWx0TG9nZ2VyID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGNoaWxkTmFtZSBpbiBfbG9nZ2Vyc0J5TmFtZSkge1xuICAgICAgICAgICAgICAgIF9sb2dnZXJzQnlOYW1lW2NoaWxkTmFtZV0ucmVidWlsZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBhbGwgdGhlIGludGVybmFsIGxldmVscy5cbiAgICAgIGluaGVyaXRlZExldmVsID0gbm9ybWFsaXplTGV2ZWwoXG4gICAgICAgICAgZGVmYXVsdExvZ2dlciA/IGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSA6IFwiV0FSTlwiXG4gICAgICApO1xuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsICE9IG51bGwpIHtcbiAgICAgICAgICB1c2VyTGV2ZWwgPSBub3JtYWxpemVMZXZlbChpbml0aWFsTGV2ZWwpO1xuICAgICAgfVxuICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKCh0eXBlb2YgbmFtZSAhPT0gXCJzeW1ib2xcIiAmJiB0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikgfHwgbmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgIH07XG5cbiAgICAvLyBFUzYgZGVmYXVsdCBleHBvcnQsIGZvciBjb21wYXRpYmlsaXR5XG4gICAgZGVmYXVsdExvZ2dlclsnZGVmYXVsdCddID0gZGVmYXVsdExvZ2dlcjtcblxuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xufSkpO1xuIl0sIm5hbWVzIjpbInJvb3QiLCJkZWZpbml0aW9uIiwiZGVmaW5lIiwiYW1kIiwibW9kdWxlIiwiZXhwb3J0cyIsImxvZyIsIm5vb3AiLCJ1bmRlZmluZWRUeXBlIiwiaXNJRSIsIndpbmRvdyIsIm5hdmlnYXRvciIsInRlc3QiLCJ1c2VyQWdlbnQiLCJsb2dNZXRob2RzIiwiX2xvZ2dlcnNCeU5hbWUiLCJkZWZhdWx0TG9nZ2VyIiwiYmluZE1ldGhvZCIsIm9iaiIsIm1ldGhvZE5hbWUiLCJtZXRob2QiLCJiaW5kIiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJjYWxsIiwiZSIsImFwcGx5IiwiYXJndW1lbnRzIiwidHJhY2VGb3JJRSIsImNvbnNvbGUiLCJ0cmFjZSIsInJlYWxNZXRob2QiLCJ1bmRlZmluZWQiLCJyZXBsYWNlTG9nZ2luZ01ldGhvZHMiLCJsZXZlbCIsImdldExldmVsIiwiaSIsImxlbmd0aCIsIm1ldGhvZEZhY3RvcnkiLCJuYW1lIiwiZGVidWciLCJsZXZlbHMiLCJTSUxFTlQiLCJlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzIiwiZGVmYXVsdE1ldGhvZEZhY3RvcnkiLCJfbGV2ZWwiLCJfbG9nZ2VyTmFtZSIsIkxvZ2dlciIsImZhY3RvcnkiLCJzZWxmIiwiaW5oZXJpdGVkTGV2ZWwiLCJkZWZhdWx0TGV2ZWwiLCJ1c2VyTGV2ZWwiLCJzdG9yYWdlS2V5IiwicGVyc2lzdExldmVsSWZQb3NzaWJsZSIsImxldmVsTnVtIiwibGV2ZWxOYW1lIiwidG9VcHBlckNhc2UiLCJsb2NhbFN0b3JhZ2UiLCJpZ25vcmUiLCJkb2N1bWVudCIsImNvb2tpZSIsImVuY29kZVVSSUNvbXBvbmVudCIsImdldFBlcnNpc3RlZExldmVsIiwic3RvcmVkTGV2ZWwiLCJjb29raWVOYW1lIiwibG9jYXRpb24iLCJpbmRleE9mIiwiZXhlYyIsInNsaWNlIiwiY2xlYXJQZXJzaXN0ZWRMZXZlbCIsInJlbW92ZUl0ZW0iLCJub3JtYWxpemVMZXZlbCIsImlucHV0IiwiVHlwZUVycm9yIiwic2V0TGV2ZWwiLCJwZXJzaXN0Iiwic2V0RGVmYXVsdExldmVsIiwicmVzZXRMZXZlbCIsImVuYWJsZUFsbCIsIlRSQUNFIiwiZGlzYWJsZUFsbCIsInJlYnVpbGQiLCJjaGlsZE5hbWUiLCJpbml0aWFsTGV2ZWwiLCJnZXRMb2dnZXIiLCJsb2dnZXIiLCJfbG9nIiwibm9Db25mbGljdCIsImdldExvZ2dlcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/loglevel/lib/loglevel.js\n");

/***/ })

};
;